(function() {
  /* 
  * Important note:
  *
  * The source of this JS file is auto-generated by CoffeeScript.
  * Changes made here will be overwritten. Please make your changes
  * in os.map.coffee
  *
  */  OpenSpending.Map = (function() {
    function Map(svgSrc, container, mode) {
      this.svgSrc = svgSrc;
      this.container = container;
      this.mode = mode != null ? mode : 'total';
      this.loadSVG();
    }
    Map.prototype.loadSVG = function() {
      $.ajax({
        url: this.svgSrc,
        context: this,
        success: this.svgLoaded
      });
    };
    Map.prototype.svgLoaded = function(svg) {
      var path, paths, regionMapSrc, region_id, _i, _len, _ref;
      this.mapSrcWidth = this.valueFromPixel(svg.childNodes[2].getAttribute('width'));
      this.mapSrcHeight = this.valueFromPixel(svg.childNodes[2].getAttribute('height'));
      paths = svg.getElementsByTagName('path');
      regionMapSrc = {};
      this.populationPerRegion = {};
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        if ((path.getAttribute != null) && path.getAttribute('class') === 'region' && (path.getAttribute('d') != null)) {
          region_id = path.getAttribute('region');
                    if ((_ref = regionMapSrc[region_id]) != null) {
            _ref;
          } else {
            regionMapSrc[region_id] = [];
          };
          regionMapSrc[region_id].push(path.getAttribute('d'));
          if (path.getAttribute('population') != null) {
            this.populationPerRegion[region_id] = path.getAttribute('population');
          }
        }
      }
      this.mapSrc = regionMapSrc;
      this.initMap();
    };
    Map.prototype.valueFromPixel = function(px) {
      return Number(px.substr(0, px.length - 2));
    };
    Map.prototype.initMap = function() {
      var id, path, pathSrcs, ps, _i, _len, _ref;
      this.paper = new Raphael(this.container[0], this.container.width(), this.container.height());
      this.paths = [];
      this.pathsByRegion = {};
      _ref = this.mapSrc;
      for (id in _ref) {
        pathSrcs = _ref[id];
        this.pathsByRegion[id] = [];
        for (_i = 0, _len = pathSrcs.length; _i < _len; _i++) {
          ps = pathSrcs[_i];
          path = this.createPath(ps);
          this.paths.push(path);
          path.node.setAttribute('region:id', id);
          path.node.setAttribute('map:instance', this);
          this.pathsByRegion[id].push(path);
          $(path.node).tooltip({
            delay: 100,
            bodyHandler: this.getRegionTooltip
          });
        }
      }
      this.scaleMap();
      $(window).resize(this.scaleMap.bind(this));
    };
    Map.prototype.createPath = function(src) {
      var path;
      return path = this.paper.path(src).attr({
        fill: '#ccc',
        stroke: false
      });
    };
    Map.prototype.getRegionTooltip = function() {
      var map, rid;
      map = this.getAttribute('map:instance');
      rid = this.getAttribute('region:id');
      return this.getAttribute('tooltip');
    };
    Map.prototype.scaleMap = function() {
      var h, path, scale, transform, w, xo, yo, _i, _len, _ref, _ref2;
      _ref = [this.container.width(), this.container.height()], w = _ref[0], h = _ref[1];
      this.paper.setSize(w, h);
      scale = Math.min(h * 0.85 / this.mapSrcHeight, w * 0.85 / this.mapSrcWidth);
      xo = (w - this.mapSrcWidth * scale) * 0.5;
      yo = (h - this.mapSrcHeight * scale) * 0.5;
      transform = "scale(" + scale + ") translate(" + xo * scale + ", " + yo * scale + ")";
      _ref2 = this.paths;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        path = _ref2[_i];
        path.node.setAttribute("transform", transform);
      }
    };
    Map.prototype.updateValues = function(node) {
      var color, id, ma, path, population, subnode, total, _i, _len, _ref, _ref2, _ref3;
      this.currentNode = node;
      total = node.amount;
      console.log('map.mode = ', this.mode);
      ma = 0;
      _ref = node.breakdowns;
      for (id in _ref) {
        subnode = _ref[id];
        if (this.pathsByRegion[id] != null) {
          population = this.populationPerRegion[id];
          switch (this.mode) {
            case 'total':
              ma = Math.max(ma, subnode.amount);
              break;
            case 'percapita':
              ma = Math.max(ma, subnode.amount / population);
              break;
            default:
              vis4.log('unsupported map mode ' + this.mode);
          }
        }
      }
      _ref2 = node.breakdowns;
      for (id in _ref2) {
        subnode = _ref2[id];
        if (this.pathsByRegion[id] != null) {
          population = this.populationPerRegion[id];
          console.log(id, 'pop = ', population);
          switch (this.mode) {
            case 'total':
              color = vis4color.fromHSL(330, .3, .9 - subnode.amount / ma * .5).x;
              break;
            case 'percapita':
              color = vis4color.fromHSL(330, .3, .9 - (subnode.amount / population) / ma * .5).x;
              break;
            default:
              vis4.log('unsupported map mode ' + this.mode);
          }
          _ref3 = this.pathsByRegion[id];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            path = _ref3[_i];
            path.node.setAttribute('tooltip', '<div class="label">' + subnode.label + '</div><div>Total: <span  class="amount">' + subnode.famount + '</span> (' + Math.round(subnode.amount / node.amount * 100) + '%)</div>');
            path.animate({
              fill: color
            }, 300);
          }
        }
      }
    };
    return Map;
  })();
}).call(this);
