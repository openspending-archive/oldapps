/*!
 * OpenSpendings BubbleChart 0.1
 *
 * Copyright (c) 2011 Gregor Aisch (http://driven-by-data.net)
 * Licensed under the MIT license
 */
/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN */

var OpenSpendings = OpenSpendings ? OpenSpendings : {}; 

OpenSpendings.BubbleChart = function(container, urlOrTree, hoverCallback, unhoverCallback) {
	var me = this;
	me.container = container;
	me.urlOrTree = urlOrTree;
	me.hoverCallback = hoverCallback;
	me.unhoverCallback = unhoverCallback;
		
	//$(document).ready(function() {
		me.app = new OpenSpendings.BubbleChart.Main(me.container, me.hoverCallback, me.unhoverCallback);
		if (typeof(me.urlOrTree) == "string") {
			me.app.loadData(me.urlOrTree);
		} else {
			me.app.setData(me.urlOrTree);
		}
	//}.bind(this));
	
};



OpenSpendings.BubbleChart.Vector = function(x,y) {
	var me = this;
	me.x = x; 
	me.y = y;
	
	/*
	 * calculates the length of the vector
	 */
	this.length = function() {
		var me = this;
		return Math.sqrt(me.x*me.x + me.y * me.y);
	};
	
	/*
	 * changes the length of the vector
	 */
	this.normalize = function(len) {
		var me = this, l = me.length();
		if (!len) len = 1.0;
		me.x *= len/l;
		me.y *= len/l;
	};
	
	/*
	 * creates an exact copy of this vector
	 */
	this.clone = function() {
		var me = this;
		return new OpenSpendings.BubbleChart.Vector(me.x, me.y);
	};
};


/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */

var log = window.console ? console.log : function(a,b,c,d) {};
/*
 * is constructed after the container page has been loaded
 */
OpenSpendings.BubbleChart.Main = function(container, onHover, onUnHover) {
	// init the page content (create divs, init Raphael paper etc)
	// load the data, url should be provided 
	// init the bubbles
	
	var me = this;
	
	me.$container = $(container);	
	
	/*
	 * this function is called when the user hovers a bubble
	 */
	me.onHover = onHover;
	
	me.onUnHover = onUnHover;
	
	me.ns = OpenSpendings.BubbleChart;
	
	me.nodesById = {};
	
	me.bubbles = [];
	
	me.bubbleScale = 1;
	
	me.globRotation = 0;
	
	me.currentCenter = undefined;
	
	/*
	 * @public loadData
	 * 
	 */
	me.loadData = function(url) {
		$.ajax({
			url: url,
			dataType: 'json',
			success: this.setData.bind(this)
		});
	};
	
	/*
	 * is either called directly or by $.ajax when data json file is loaded
	 */
	me.setData = function(data) {
		var me = this;
		me.initData(data);
		me.initPaper();
		me.initTween();
		me.changeView(me.treeRoot.id);
		//this.quickPrototype(data);
	};
	
	/*
	 * initializes the data tree, adds links to parent node for easier traversal etc
	 */
	this.initData = function(root) {
		this.traverse(root, 0);
		this.treeRoot = root;
	};
	
	/*
	 * used for recursive tree traversal
	 */
	this.traverse = function(node, index) {
		var c, child, pc;
		// set node color
		if (node.level === 0) node.color = '#555';
		else if (node.level == 1) {
			pc = node.parent.children;
			node.color = 'hsb('+(index/pc.length)+',.8, .8)';
		} else {
			// inherit color form parent node
			node.color = node.parent.color;
		}
		if (node.level > 0) {
			pc = node.parent.children;
			if (pc.length > 1) {	
				node.left = pc[(index-1+pc.length) % pc.length];
				node.right = pc[(Number(index)+1) % pc.length];
				if (node.right == node.left) node.right = undefined;
			}
		}
		
		if (!node.id) {
			node.id = node.label.toLowerCase().replace(/\W/g, "_");
			while (this.nodesById.hasOwnProperty(node.id)) {
				node.id += '_';
			}
		} 
		this.nodesById[node.id] = node;
		for (c in node.children) {
			child = node.children[c];
			child.parent = node;
			this.traverse(child, c);
		}
	};
	
	/*
	 * initializes all that RaphaelJS stuff
	 */
	this.initPaper = function() {
		var $c = this.$container,
			paper = Raphael($c[0], $c.width(), $c.height()),
			Vector = OpenSpendings.BubbleChart.Vector,
			origin = new Vector(paper.width * 0.5, paper.height * 0.5); // center
			
		this.paper = paper;
		this.origin = origin;
	};
	
	/*
	 * initializes the Tweening engine
	 */
	this.initTween = function() {
		this.tweenTimer = setInterval(this.loop, 1000/120);
	};
	
	/*
	 * is called every time the user changes the view
	 * each view is defined by the selected node (which is displayed 
	 */
	this.changeView = function(id) {
		
		var me = this, i, paper = me.paper,
			ns = me.ns, 
			utils = ns.Utils, 
			o = me.origin,
			l1attr = { stroke: '#ccc', 'stroke-dasharray': "- " },
			l2attr = { stroke: '#ccc', 'stroke-dasharray': ". " },
			a2rad = utils.amount2rad,
			root = me.treeRoot, 
			nodesById = me.nodesById, 
			node = nodesById.hasOwnProperty(id) ? nodesById[id] : null,
			t = new ns.Layout(), bubble;
		

		if (node !== null) {
			
			utils.log('changing view to ', node);
								
			// mark all existing objects for removal here, will be
			// set to false for all bubbles that may stay
			for (i in me.bubbles) me.bubbles[i].removable = true;
			for (i in me.rings) me.rings[i].remove();
			me.rings = [];


			var childRadSum = 0, children = node.children,
				c, ca, da, oa, twopi = Math.PI * 2;

			// store the last centered bubbles angle if it's on level 1
			if (me.currentCenter && me.currentCenter.node.level == 1) {
				me.globRotation = 0-me.currentCenter.node.centerAngle;
			}
			
			oa = me.globRotation;

			if (node == root) {
			
				t.$(me).bubbleScale = 1.0;
				
				// create root
				bubble = me.createBubble(root, t, 0, 0, root.color);
				bubble.origin = o;
				
				// move origin to center
				t.$(o).x = paper.width * 0.5;
				t.$(o).y = paper.height * 0.5;
				
				me.createRing(t, bubble.origin, 240, l1attr);
				
				// sum radii of all children
				for (i in children) {
					c = children[i];
					childRadSum += a2rad(c.amount);
				}
				
				// create all child bubbles
				for (i in children) {
					c = children[i];
					da = a2rad(c.amount) / childRadSum * twopi;
					ca = oa + da*0.5;
					if (!c.hasOwnProperty('centerAngle')) c.centerAngle = ca;
					oa += da;
					// children will reference to the same origin
					bubble = me.createBubble(c, t, 240, ca, c.color);
					bubble.origin = o;
				}

				// just children and me
			} else {
			
				var parentBubble, tgtScale = a2rad(root.amount) / a2rad(node.amount);
				t.$(me).bubbleScale = tgtScale;
				
				var sibling, po = new ns.Vector(me.paper.width * 0.5 - 280 - 
					tgtScale * (a2rad(node.parent.amount)+a2rad(node.amount)), o.y);
				
				// create parent node and give it the new parent origin
				parentBubble = me.createBubble(node.parent, t, 0, 0, node.parent.color);
				parentBubble.origin = o;
				
				// move origin to the left
				t.$(o).x = po.x;
				
				me.createRing(t, po, o.x - po.x, l2attr);
				
				
				// left and right sibling
				if (node.left) {
					sibling = node.left;
					da = (a2rad(sibling.amount)*tgtScale - 100)/(twopi*((o.x-po.x)));
					bubble = me.createBubble(sibling, t, o.x - po.x, 
						0-Math.asin((me.paper.height)*0.5/(o.x-po.x))-da, sibling.color);
					bubble.origin = parentBubble.pos;
				}
				if (node.right) {
					sibling = node.right;
					da = (a2rad(sibling.amount)*tgtScale - 100)/(twopi*((o.x-po.x)));
					bubble = me.createBubble(sibling, t, o.x - po.x, 
						da+Math.asin((me.paper.height+a2rad(sibling.amount)*me.bubbleScale)*0.5/(o.x-po.x)), sibling.color);
					bubble.origin = parentBubble.pos;
				}
				
				// center
				bubble = me.createBubble(node, t, paper.width * 0.5 - po.x, 0, node.color);
				bubble.origin = parentBubble.pos;
				me.createRing(t, bubble.origin, 240, l1attr);
				
				// store the center bubble
				me.currentCenter = bubble;
				
				for (i in children) {
					c = children[i];
					childRadSum += a2rad(c.amount);
				}
	
				oa -= Math.PI;
	
				for (i in children) {
					c = children[i];
					da = a2rad(c.amount) / childRadSum * twopi;
					ca = oa + da*0.5;
					oa += da;
					var child = me.createBubble(c, t, 240, ca, node.color);
					child.origin = bubble.pos;
				}
				
			}
			
			// remove any bubbles that are marked for removal
			var tmpBubbles = [];
			for (i in me.bubbles) {
				bubble = me.bubbles[i];
				if (bubble.removable) {
					t.$(bubble).alpha = 0;
					if (bubble.node.level > 1) t.$(bubble).rad = 0;
				} else {
					tmpBubbles.push(bubble);
				}
			}
			me.bubbles = tmpBubbles;
			
			
			utils.log('ready');
			new ns.AnimatedTransitioner().changeLayout(t);
				
		} else {
			utils.log('node '+id+' not found');
		}
		// step1: 
		
		// step2: 
	};
	
	/*
	 * either creates a new bubble or re-uses a bubble which already exists
	 */
	this.createBubble = function(node, t, rad, angle, color) {
		var me = this, ns = me.ns, i, b, bubble;
		
		for (i in me.bubbles) {
			b = me.bubbles[i];
			if (b.node == node) {
				bubble = b;
				continue;
			}
		}
		if (!bubble) {
			// we need to create a new bubble
			bubble = new ns.Bubble(node, me, new ns.Vector(0,0), 0, 0, color);
			me.bubbles.push(bubble);
		}
		bubble.removable = false;
		t.$(bubble).rad = rad;
		t.$(bubble).angle = angle;
		return bubble;
	};
	
	this.createRing = function(t, origin, rad, attr) {
		var me = this, ns = me.ns, 
			ring = new ns.Ring(me, origin, attr, rad);
		me.rings.push(ring);
		t.$(ring).rad = rad;
		return ring;
	};
	/*
	this.quickPrototype = function(root) {
		
		var origin = this.origin, // center
			paper = this.paper,
			l1rad = paper.height * 0.30, // radius for level 1 nodes
			l2rad = paper.height * 0.45, // radius for level 2 nodes
			lcircAttrs = { stroke: '#ccc', 'stroke-dasharray': "- " },
			a2rad = OpenSpendings.BubbleChart.amount2rad,
			l1alpha = Math.PI * 2 / root.children.length;
			
		// level 1 circle
		
		
		this.l1Circ = new OpenSpendings.BubbleChart.Ring(this, lcircAttrs, l1rad);
		this.l2Circ = new OpenSpendings.BubbleChart.Ring(this, lcircAttrs, l2rad);
			
		this.rootCircle = new OpenSpendings.BubbleChart.Bubble(root, this, 0, 0, '#555555' );
			
		var l1a = 0, da1, i, j, ca1, col, l1radsum = 0, l2radsumt = 0;
		
		var _r = function(a) { return Math.round(Raphael.deg(a)*10)/10; };
		
		for (i in root.children) {
			for (j in root.children[i].children) {
				l2radsumt += a2rad(root.children[i].children[j].amount);
			}
		}
		
		//for (i in root.children) l1radsum += a2rad(root.children[i].amount);
		
		var cmpNodes = function(a,b) {
			if (a.amount == b.amount) return 0;
			return a.amount > b.amount ? -1 : 1;
		};
		
		this.innerRing = [];
		this.outerRing = [];
		this.innerLines = [];
		
		
		
		for (i in root.children) {
			
			
			
			var l2radsum = 0;
			var node = root.children[i];
			
			for (j in node.children) l2radsum += a2rad(node.children[j].amount);
			
			da1 = (l2radsum / l2radsumt) * Math.PI * 2;
			ca1 = l1a + da1*0.5;
			col = 'hsb('+(i/root.children.length)+',.8, .8)';
			
			this.innerRing.push(new OpenSpendings.BubbleChart.Bubble(node, this, origin, l1rad, ca1, col));
			
			this.innerLines.push(new OpenSpendings.BubbleChart.Line(this, lcircAttrs, origin, ca1, l1rad + a2rad(node.amount), l2rad));
			
			
			// cycle through level 2 children
			var l2a = l1a, da2, ca2;
			
			var old = node.children;
			
			old.sort(cmpNodes);
			
			node.children = old;// [].concat(old.slice(0,old.length/2), old.slice(old.length/2).reverse());
			
			//var tmp = da1 * 0.8;
			//l2a += (da1 - tmp) * 0.5;
			
			var cUp = l2a + da1 * 0.5, cLow = cUp, space = 0;// Math.atan(10/l2rad);
			
			for (j in node.children) {
				
				var subnode = node.children[j];
				var brad = OpenSpendings.BubbleChart.amount2rad(subnode.amount);
				var barc = Math.atan(brad / l2rad)*2;
				
				if (j === 0) {
					ca2 = cUp;
					cUp -= (barc + space);
					cLow += (barc + space);
				} else if (j % 2 === 0) {
					ca2 = cUp - barc;
					cUp -= barc + space;
				} else {
					ca2 = cLow + barc;
					cLow += barc + space;
				}
				
				//console.log(j, ca2, barc, cUp, cLow);
				
				//da2 = (a2rad(subnode.amount) / l2radsum) * tmp; 
				
				//ca2 = l2a + da2 * 0.5;
				
				
				
				this.outerRing.push(new OpenSpendings.BubbleChart.Bubble(subnode, this, l2rad, ca2, col));

				//l2a += da2;
			}
			
			l1a += da1;
		}
			
	};*/
	
	/*
	 * is called either by click on one of the bubbles
	 * or by url change (later)
	 *
	this.scrollTo = function(bubble) {
		var delta = -bubble.angle, i, b, outerRad, ox = this.paper.width * 0.5, 
			scale, innerRad, ease = TWEEN.Easing.Exponential.EaseOut;
		
		//var t = new FlareJS.Transitioner(1000, ease);
		var t = {};
		
		if (bubble == this.rootCircle) {
			innerRad = this.paper.height * 0.3;
			outerRad = this.paper.height * 0.45;
			scale = 1.0;
		} else if ($.inArray(bubble, this.innerRing)) {
			innerRad = this.paper.height * 1.4;
			outerRad = this.paper.height * 1.8;
			scale = 8.0;
			ox -= innerRad;
		} else {
			innerRad = this.paper.height * 0.5;
			outerRad = this.paper.height * 0.8;
			ox -= outerRad;
			scale = 3.0;
		}
		
		if (Math.abs(delta) > Math.PI) {
			delta += delta > 0 ? -Math.PI*2 : Math.PI*2;
		}
		
		t.$(this.origin).x = ox;
		t.$(this).bubbleScale = scale;
		t.$(this.rootCircle).foo = 1000;
		
		
		for (i in this.innerRing) {
			b = this.innerRing[i];
			new TWEEN.Tween(b)
				.to({ angle: b.angle+delta, rad: innerRad }, 1000)
				.onUpdate(b.draw.bind(b))
				.easing(ease)
				.start();
			var l = this.innerLines[i];
			new TWEEN.Tween(l)
				.to({ angle: b.angle+delta, fromRad: innerRad + b.bubbleRad * scale, toRad: outerRad }, 1000)
				.onUpdate(l.draw.bind(l))
				.easing(ease)
				.start(); 
		}
		
		for (i in this.outerRing) {
			b = this.outerRing[i];
			new TWEEN.Tween(b)
				.to({ angle: b.angle+delta, rad: outerRad }, 1000)
				.onUpdate(b.draw.bind(b))
				.easing(ease)
				.start();
		}
		this.rotation += delta;
		
		t.$(this.l1Circ).rad = innerRad;
		t.$(this.l2Circ).rad = outerRad;
		t.start();
	};*/
	
	this.loop = function() {
		TWEEN.update();
	};
	
};

/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */

/*
 * represents a bubble
 */
OpenSpendings.BubbleChart.Bubble = function(node, bubblechart, origin, radius, angle, colour) {

	var ns = OpenSpendings.BubbleChart, utils = ns.Utils, me = this;
	me.node = node;
	me.paper = bubblechart.paper;
	me.origin = origin;
	me.bc = bubblechart;
	me.rad = radius;
	me.angle = angle;
	me.colour = colour;
	me.dirty = true;
	me.alpha = 1;
	me.ns = ns;
	me.bubbleRad = utils.amount2rad(this.node.amount);
	
	/*
	 * convertes polar coordinates to x,y
	 */
	me.getXY = function() {
		var me = this, o = me.origin, a = me.angle, r = me.rad;
		me.pos.x = o.x + Math.cos(a) * r;
		me.pos.y = o.y - Math.sin(a) * r;
	};
	
	/*
	 * inistalizes the bubble
	 */
	me.init = function() {
		var me = this;
		me.pos = new OpenSpendings.BubbleChart.Vector(0,0);
		me.getXY();
		me.circle = me.paper.circle(me.pos.x, me.pos.y, me.bubbleRad * me.bc.bubbleScale)
			.attr({ stroke: false, fill: me.colour });
		me.dirty = false;
		$(me.circle.node).css({ cursor: 'pointer'});
		
		var showIcon = false; //this.bubbleRad * this.bc.bubbleScale > 30;
		// create label
		/*this.label = me.paper.text(me.pos.x, me.pos.y + (showIcon ? me.bubbleRad * 0.4: 0), utils.formatNumber(me.node.amount)+'\n'+me.node.label)
			.attr({ 'font-family': 'Graublau,Georgia,serif', fill: '#fff', 'font-size': Math.max(4, me.bubbleRad * me.bc.bubbleScale * 0.25) });
		*/
		me.label = $('<div class="label"><div class="amount">'+utils.formatNumber(me.node.amount)+'</div><div class="desc">'+me.node.label+'</div></div>');
		$('#bubble-chart').append(me.label);
		
		if (showIcon) {
			me.icon = me.paper.path("M17.081,4.065V3.137c0,0,0.104-0.872-0.881-0.872c-0.928,0-0.891,0.9-0.891,0.9v0.9C4.572,3.925,2.672,15.783,2.672,15.783c1.237-2.98,4.462-2.755,4.462-2.755c4.05,0,4.481,2.681,4.481,2.681c0.984-2.953,4.547-2.662,4.547-2.662c3.769,0,4.509,2.719,4.509,2.719s0.787-2.812,4.557-2.756c3.262,0,4.443,2.7,4.443,2.7v-0.058C29.672,4.348,17.081,4.065,17.081,4.065zM15.328,24.793c0,1.744-1.8,1.801-1.8,1.801c-1.885,0-1.8-1.801-1.8-1.801s0.028-0.928-0.872-0.928c-0.9,0-0.957,0.9-0.957,0.9c0,3.628,3.6,3.572,3.6,3.572c3.6,0,3.572-3.545,3.572-3.545V13.966h-1.744V24.793z")
				.translate(me.pos.x, me.pos.y).attr({fill: "#fff", stroke: "none"});
		}
		
		//$(me.circle.node).hover(me.onhover.bind(me), me.onunhover.bind(me));
		//$(me.circle.node).click(me.onclick.bind(me))u
		
		var mgroup = new me.ns.MouseEventGroup(me, [me.circle.node, me.label]);
		mgroup.click(me.onclick.bind(me));
		mgroup.hover(me.onhover.bind(me));
		mgroup.unhover(me.onunhover.bind(me));
		
		me.initialized = true;
	};
	
	/*
	 *
	 */
	me.onclick = function(e) {
		var me = this;
		me.ns.Utils.log('click! ', e);
		me.bc.changeView(me.node.id);
	};
	
	me.onhover = function(e) {
		var me = this;
		me.ns.Utils.log('hover!', e);
		e.node = me.node;
		e.position = { x:me.pos.x, y: me.pos.y };
		me.bc.onHover(e);
	};
	
	me.onunhover = function(e) {
		var me = this;
		me.ns.Utils.log('unhover!', e);
		e.node = me.node;
		e.position = { x:me.pos.x, y: me.pos.y };
		me.bc.onUnHover(e);
	};
	
	
	
	this.draw = function() {
		var me = this, r= me.bubbleRad * me.bc.bubbleScale, ox = me.pos.x, oy = me.pos.y, devnull = me.getXY();
		me.circle.attr({ cx: me.pos.x, cy: me.pos.y, r: r, 'fill-opacity': me.alpha });
		//me.label.attr({ x: me.pos.x, y: me.pos.y, 'font-size': Math.max(4, me.bubbleRad * me.bc.bubbleScale * 0.25) });
		me.label.css({ width: 2*r+'px', opacity: me.alpha });
		me.label.css({ left: (me.pos.x-r)+'px', top: (me.pos.y-me.label.height()*0.5)+'px' });
		if (me.icon) me.icon.translate(me.pos.x - ox, me.pos.y - oy);
	};
	
	this.remove = function() {
		var me = this;
		me.circle.remove();
		me.label.remove();
		//$('#bubble-chart')
		me.initialized = false;
		if (me.icon) me.icon.remove();
	};
	
	this.init();
};/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */

/*
 * stores visual attributes of all elements in the visualization
 * 
 */
OpenSpendings.BubbleChart.Layout = function() {

	this.objects = [];
	this.props = [];
	
	/*
	 * flare-style transitioner syntax
	 *
	 * if you have an object bubble, you can easily change its properties with
	 * 
	 * var l = new OpenSpendings.BubbleChart.Layout();
	 * l.$(bubble).radius = 30;
	 * l.$(bubble).angle = 3.14;
	 */
	this.$ = function(obj) {
		for (var i in this.objects) {
			var o = this.objects[i];
			if (o == obj) return this.props[i];
		}
		this.objects.push(obj);
		var p = {};
		this.props.push(p);
		return p;
	};
	
};/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */
/*
 * represents a radial line
 */
OpenSpendings.BubbleChart.Line = function(bc, attr, origin, angle, fromRad, toRad) {
	this.bc = bc;
	this.o = origin;
	this.angle = angle;
	this.fromRad = fromRad;
	this.attr = attr;
	this.toRad = toRad;
	
	this.getXY = function() {
		this.x1 = this.o.x + Math.cos(this.angle) * this.fromRad; 
		this.y1 = this.o.y -Math.sin(this.angle) * this.fromRad;
		this.x2 = this.o.x + Math.cos(this.angle) * this.toRad; 
		this.y2 = this.o.y  -Math.sin(this.angle) * this.toRad;
	};
	
	this.init = function() {
		this.getXY();
		console.log("foo", "M"+this.x1+" "+this.y1+"L"+this.x2+" "+this.y2, attr);
		this.path = this.bc.paper.path(
			"M"+this.x1+" "+this.y1+"L"+this.x2+" "+this.y2
		).attr(this.attr);
	};
	
	this.draw = function() {
		//console.log('line.draw()', this.angle, this.fromRad, this.toRad);
		//console.log(this.x1, this);
		this.getXY();
		//console.log(this.x1);
		this.path.attr({ path: "M"+this.x1+" "+this.y1+"L"+this.x2+" "+this.y2 });
	};
	
	
	this.init();
	
};/*
 * in JS there's no thing like mouse event capsulation, this
 * class will work around this. It makes it possible to set
 * events like click and hover for a group of objects that
 * belong together
 */
OpenSpendings.BubbleChart.MouseEventGroup = function(target, members) {
	
	var me = this;
	me.target = target; // e.g. instance of a bubble
	me.members = members; // e.g. raphael nodes or html elements
	
	/*
	 * public interface for setting click handlers
	 */
	me.click = function(callback) {
		var me = this, members = me.members, i, mem;
		me.clickCallback = callback;
		for (i in members) {
			mem = members[i];
			$(mem).click(me.handleClick.bind(me));
		}
	};
	
	me.handleClick = function(evt) {
		var me = this;
		me.clickCallback({ target: me.target, origEvent: evt, mouseEventGroup: me });
	};
	
	/*
	 *
	 */
	me.hover = function(callback) {
		var me = this, members = me.members, i, mem;
		me.hoverCallback = callback;
		for (i in members) {
			mem = members[i];
			$(mem).hover(me.handleMemberHover.bind(me), me.handleMemberUnHover.bind(me));
		}
	};
	
	/*
	 * public interface for setting unhover callback
	 */
	me.unhover = function(callback) {
		var me = this;
		me.unhoverCallback = callback;
	};
	
	/*
	 * stores wether the mouse currently hover over any
	 * object in our members list. this is used to check
	 * wether a occuring hover event is an actual hover
	 * event.
	 */
	me.wasHovering = false;
	me.mouseIsOver = false;
	
	me.handleMemberHover = function(evt) {
		var me = this;
		vis4.log('handleMemberHover', evt.target);
		// since we don't know which event will receive first, the unhover of the member
		// the mouse is leaving or the hover of the member the mouse is entering, we will
		// delay the final check a bit
		new vis4.DelayedTask(25, me, me.handleMemberHoverDelayed, evt);	
		vis4.log('--- handleMemberHover');
		
	};

	/*
	 * will be called after all unhover events are processed
	 */
	me.handleMemberHoverDelayed = function(evt) {
		var me = this;
		// this will eventually override the false set by handleMemberUnHover a few
		// milliseconds ok. Exactly what we want!
		me.mouseIsOver = true;
		vis4.log('handleMemberHoverDelayed', evt);
				
		if (!me.wasHovering) {
			// the target is newly hovered
			vis4.log('mouseEventGroup - hover', me, evt);
			
			me.wasHovering = true;
			if ($.isFunction(me.hoverCallback)) {
				me.hoverCallback({ target: me.target, origEvent: evt, mouseEventGroup: me });
			}
		} // else can be ignored, no news
	};
	

	me.handleMemberUnHover = function(evt) {
		var me = this;
		me.mouseIsOver = false;
		vis4.log('handleMemberUnHover', evt.target);
		// we need to wait a bit to find out if this is a real unhover event
		// or just the change to another element in the member list
		// so we need to delay the final check a bit (let's say 30ms)
		new vis4.DelayedTask(40, me, me.handleMemberUnHoverDelayed, evt);	
	};
	
	me.handleMemberUnHoverDelayed = function(evt) {
		var me = this;
		vis4.log('handleMemberUnHoverDelayed', evt);
		if (!me.mouseIsOver) {
			vis4.log('mouseEventGroup - unhover', me, evt);
			// well, finally no nasty hover event has disturbed our good unhover
			// process, so we can assume that this is a real unhover event
			
			me.wasHovering = false;
			if ($.isFunction(me.unhoverCallback)) {
				me.unhoverCallback({ target: me.target, origEvent: evt, mouseEventGroup: me });
			}
		}
	};
		
	/*
	 * this function is used for later addition of member objects like dynamic tooltips
	 */
	me.addMember = function(mem) {
		var me = this;
		if (me.clickCallback) $(mem).click(me.handleClick.bind(me));
		if (me.hoverCallback) $(mem).hover(me.handleMemberHover.bind(me), me.handleMemberUnHover.bind(me));
		me.members.push(mem);
	};
	
	/*
	 * this function is used for later removal of member objects like dynamic tooltips
	 */
	me.removeMember = function(mem) {
		var me = this, members = me.members, i, tmp = [];
		if (me.clickCallback) $(mem).unbind('click');
		if (me.hoverCallback) $(mem).unbind('mouseenter mouseleave');
		for (i in members) {
			if (members[i] != mem) tmp.push(members[i]);
		}
		me.members = tmp;
		
	};
};
/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */

/*
 * represents a ring
 */
OpenSpendings.BubbleChart.Ring = function(bc, o, attr, rad) {
	this.rad = rad;
	this.bubblechart = bc;
	this.attr = attr;
	this.origin = o;
	
	this.init = function() {
		var o = this.origin;
		this.circle = this.bubblechart.paper.circle(o.x, o.y, this.rad).attr(this.attr);
	};
	
	this.draw = function() {
		var o = this.origin;
		this.circle.attr({ cx: o.x, cy: o.y, r: this.rad });
	};
	
	/*
	 * removes all raphael nodes from stage
	 */
	this.remove = function() {
		var me = this;
		me.circle.remove();
	};
	
	this.init();
};/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */

/*
 * transforms the current display to a new layout
 * while transitioning, there are several possible cases:
 * - a node exists both before and after the transition
 * - a node appears at the beginning of the transition
 * - a node disappears at the end of the transtion
 */
OpenSpendings.BubbleChart.SimpleTransitioner = function() {
	
	this.changeLayout = function(layout) {

		var i, o, props, p;
		for (i in layout.objects) {
			o = layout.objects[i];
			if (o === undefined || o === null) continue;
			props = layout.props[i];
			for (p in props) {
				o[p] = props[p];
			}
			if ($.isFunction(o.draw)) o.draw();
		}
	};
	
};

OpenSpendings.BubbleChart.AnimatedTransitioner = function() {
	
	var me = this;
	
	me.changeLayout = function(layout) {
		var i, o, props, p, me = this;
		for (i in layout.objects) {
			o = layout.objects[i];
			if (o === undefined || o === null) continue;
			props = layout.props[i];
			
			var tween = new TWEEN.Tween(o), toProps = {};
			
			for (p in props) {
				//o[p] = props[p];
				toProps[p] = props[p];
			}
			tween.to(toProps, 1000);
			if ($.isFunction(o.draw)) tween.onUpdate(o.draw.bind(o));
			tween.easing(TWEEN.Easing.Exponential.EaseOut);
			if (o.removable) {
				if (me.garbage.length === 0) {
					// at least one tween should trigger the gc
					tween.onComplete(me.collectGarbage.bind(me));
				}
				me.garbage.push(o);
			}
			
			tween.start();
		}
	};
	
	me.garbage = [];
	
	/*
	 * calls the remove() function on every object marked for
	 * removal. will run right after the tween ends
	 */
	me.collectGarbage = function() {
		OpenSpendings.BubbleChart.Utils.log('collecting garbage', this.garbage);
		var i, o, me = this;
		for (i in me.garbage) {
			o = me.garbage[i];
			if ($.isFunction(o.remove)) o.remove();
		}
		me.garbage = [];
	};
	
	
	
};/**
 * Call the wdmmg aggregate api function (/api/2/aggregate)
 * and build a tree that can be used by for the bubble charts
 *
 * @public getTree
 *
 * @param {string} api_url The url to the api,
 * e.g. 'http://openspending.org/api'
 * @param {string} dataset The name of the dataset, e.g. 'cra'
 * @param {array} cuts The array with cuts, each element in the
 * format 'key:value', e.g. ['time.from.year:2010']
 * @param {array} drilldowns the dimensions to drill down to, e.g.
 * ['cofog1', 'cofog2', 'cofog3']
 * @param {string} test_data_path (optional) Pass the path to
 * a json sample file for tests.
 **/

OpenSpendings.BubbleChart.getTree = function(api_url, dataset, cuts, drilldowns, test_data_path) {

    //construct the url
    var url = api_url,
        data = '',
        tree_root;
    url = url + '/2/aggregate';

    data = 'dataset=' + dataset;

    cuts.forEach(function(cut){
        data = data + "&cut=" + cut;
    });

    drilldowns.forEach(function(drilldown){
        data = data + "&drilldown=" + drilldown;
    });

    /**
     *  Add a node for each drilldown to the 'nodes' object
     *  Process the nodes to have:
     *  * The summed up amount
     *  * A children array
     *  * A color property
     *  * An unique id
     *
     *  @method processEntry
     *  @param {object} entry The entry in the list of drill downs
     *  @param {object} nodes Object used as a mapping for node ids to nodes
     *  @return {undefined}
     */
    var processEntry = function(entry, nodes) {

        var parent = nodes.root,
            level = 0;

        drilldowns.forEach(function(drilldown) {
            var current,
                node;
            level = level + 1;
            current = entry[drilldown];

            // Don't process the drilldowns further if a
            // drilldown has no value
            if(! current) {
                return;
            }

            node = nodes[current.name];
            if(node === undefined) {
                // Initialize a new node and add it to the parent node
                node = {id: current.name,
                        children: [],
                        amount: entry.amount,
                        label: current.label,
                        color: current.color,
                        level: level};

                parent.children.push(node);
                nodes[current.name] = node;

            } else {
                // update the ammount for existing nodes.
                node.amount = node.amount + entry.amount;
            }

            // Add the current amount to the root node
            // to have a total.
            if(level === 1) {
                nodes.root.amount = nodes.root.amount + entry.amount;
            }

            parent = node;
        });
    };

    /**
     * Build a tree form the drill down entries
     *
     * @param {object} The json object responded from the
     * aggregate api.
     *
     */
    var buildTree = function(data) {

        var entries = data.drilldown,
            nodes = {};

        if(data.errors !== undefined) {
            throw "Error";
            }

        nodes.root = {id: 'root',
                      label: 'Total',
                      color: '#555',
                      amount: 0.0,
                      children: [],
                      level: 0};

        entries.forEach(function(entry) {
            processEntry(entry, nodes);
        });

        // sum up the amount for the root node
        tree_root = nodes.root;
    };

    if (test_data_path !== undefined) {
        url = test_data_path;
    }

    $.ajax({
        url: url,
        data: data,
        async: false,
        dataType: 'json',
        error: function() {alert(error);},
        success: buildTree});

    return tree_root;
};/*jshint undef: true, browser:true, jquery: true, devel: true */
/*global Raphael, TWEEN, OpenSpendings */

OpenSpendings.BubbleChart.Utils = {};

OpenSpendings.BubbleChart.Utils.log = function() {
	try {
		if (window.hasOwnProperty('console')) console.log.apply(this, arguments);
	} catch (e) {}	
};

OpenSpendings.BubbleChart.Utils.amount2rad = function(a) {
	return Math.pow(a/150000000, 0.6);
};

OpenSpendings.BubbleChart.Utils.formatNumber = function(n) {
	if (n >= 1000000000000) return Math.round(n / 100000000000)/10 + 't';
	if (n >= 1000000000) return Math.round(n / 100000000)/10 + 'b';
	if (n >= 1000000) return Math.round(n / 100000)/10 + 'm';
	else return n;
	
};
